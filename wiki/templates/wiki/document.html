{% extends "templates/wiki/layout.html" %}
{% from "templates/wiki/macros/buttons.html" import ghost_button, render_icon, dropdown, dropdown_item, dropdown_end %}

{% block title %}
    {{ doc.title }}
{% endblock %}

{% block body %}
<div x-data="wikiPage" x-init="$store.navigation.init()">
    <!-- Main Content -->
    <article class="max-w-4xl mx-auto xl:mr-72 transition-opacity duration-150"
             :class="{ 'opacity-50': $store.navigation.loading }">
        <!-- Page Header -->
        <header class="mb-8 pb-4 border-b border-[var(--outline-gray-1)]">
            <h1 id="wiki-page-title" class="text-3xl font-bold text-[var(--ink-gray-9)] mb-4">{{ doc.title }}</h1>

            <!-- Action Buttons -->
            <div class="flex items-center gap-3">
                <!-- Copy Markdown Button -->
                <button @click="copyMarkdown()"
                        class="inline-flex items-center gap-2 px-3 py-1.5 text-sm font-medium text-[var(--ink-gray-5)] hover:text-[var(--ink-gray-9)] hover:bg-[var(--surface-gray-2)] rounded-md transition-colors duration-200 cursor-pointer">
                    <template x-if="!copied">
                        {{ render_icon("clipboard") }}
                    </template>
                    <template x-if="copied">
                        {{ render_icon("check", "text-[var(--ink-green-2)]") }}
                    </template>
                    <span x-text="copied ? 'Copied!' : 'Copy Markdown'"></span>
                </button>

                <!-- Ask AI Dropdown -->
                {% set ai_providers = [
                    {"key": "claude", "text": "Ask Claude", "icon": "claude"},
                    {"key": "openai", "text": "Ask OpenAI", "icon": "openai"},
                    {"key": "t3", "text": "Ask T3 Chat", "icon": "t3"},
                    {"key": "perplexity", "text": "Ask Perplexity", "icon": "perplexity"}
                ] %}
                {{ dropdown(text="Ask AI", icon="sparkles") }}
                    {% for provider in ai_providers %}
                        {{ dropdown_item(text=provider.text, icon=provider.icon, href_expr="getAIUrl('" ~ provider.key ~ "')") }}
                    {% endfor %}
                {{ dropdown_end() }}

                <!-- Edit Page Link -->
                {{ ghost_button(text="Edit Page", icon="edit", href=doc.get_edit_link(), id="wiki-edit-link") }}
            </div>
        </header>

        <!-- Page Content -->
        <div class="prose prose-lg max-w-none" id="wiki-content">
            {{ rendered_content }}
        </div>

        <!-- Previous/Next Navigation -->
        <nav id="wiki-nav-buttons" class="mt-12 pt-8 border-t border-[var(--outline-gray-1)]">
            {% if prev_doc or next_doc %}
            <div class="flex items-stretch gap-4 {{ 'justify-between' if prev_doc and next_doc else ('justify-start' if prev_doc else 'justify-end') }}">
                {% if prev_doc %}
                <a href="/{{ prev_doc.route }}"
                   @click.prevent="$store.navigation.navigateTo('{{ prev_doc.route }}')"
                   @mouseenter="$store.navigation.prefetch('{{ prev_doc.route }}')"
                   class="group flex-1 flex items-center gap-3 p-4 rounded-lg border border-[var(--outline-gray-1)] hover:border-[var(--outline-gray-2)] hover:bg-[var(--surface-gray-1)] transition-all duration-200 no-underline max-w-[50%]">
                    {{ render_icon("chevron-left", "w-5 h-5 text-[var(--ink-gray-4)] group-hover:text-[var(--ink-gray-6)] transition-colors shrink-0") }}
                    <div class="flex flex-col min-w-0">
                        <span class="text-xs font-medium text-[var(--ink-gray-4)] uppercase tracking-wide">Previous</span>
                        <span class="text-sm font-medium text-[var(--ink-gray-7)] group-hover:text-[var(--ink-gray-9)] transition-colors truncate">{{ prev_doc.title }}</span>
                    </div>
                </a>
                {% endif %}

                {% if next_doc %}
                <a href="/{{ next_doc.route }}"
                   @click.prevent="$store.navigation.navigateTo('{{ next_doc.route }}')"
                   @mouseenter="$store.navigation.prefetch('{{ next_doc.route }}')"
                   class="group flex-1 flex items-center justify-end gap-3 p-4 rounded-lg border border-[var(--outline-gray-1)] hover:border-[var(--outline-gray-2)] hover:bg-[var(--surface-gray-1)] transition-all duration-200 no-underline max-w-[50%] {{ 'ml-auto' if not prev_doc else '' }}">
                    <div class="flex flex-col items-end min-w-0">
                        <span class="text-xs font-medium text-[var(--ink-gray-4)] uppercase tracking-wide">Next</span>
                        <span class="text-sm font-medium text-[var(--ink-gray-7)] group-hover:text-[var(--ink-gray-9)] transition-colors truncate">{{ next_doc.title }}</span>
                    </div>
                    {{ render_icon("chevron-right", "w-5 h-5 text-[var(--ink-gray-4)] group-hover:text-[var(--ink-gray-6)] transition-colors shrink-0") }}
                </a>
                {% endif %}
            </div>
            {% endif %}
        </nav>

        <!-- Last Updated -->
        <div id="wiki-last-updated" class="mt-8 text-sm text-[var(--ink-gray-5)]">
            Last updated {{ last_updated }}
        </div>

        <!-- Feedback Widget (Mobile/Tablet only - hidden on xl screens where it shows in TOC sidebar) -->
        {% if wiki_space and wiki_space.enable_feedback_collection %}
        <div class="xl:hidden">
            {% include "templates/wiki/includes/feedback_widget.html" %}
        </div>
        {% endif %}
    </article>

    {% include "templates/wiki/includes/toc.html" %}
</div>

<script>
    // Initialize page content store and wikiPage component for reactive updates during navigation
    document.addEventListener('alpine:init', () => {
        Alpine.store('pageContent', {
            markdown: {{ raw_markdown | tojson }}
        });

        // Combined component for wiki document page (wikiDocument + tocScrollSpy)
        Alpine.data('wikiPage', () => ({
            // wikiDocument properties
            copied: false,

            get markdown() {
                return this.$store.pageContent?.markdown || '';
            },

            copyMarkdown() {
                navigator.clipboard.writeText(this.markdown).then(() => {
                    this.copied = true;
                    setTimeout(() => {
                        this.copied = false;
                    }, 2000);
                }).catch(err => {
                    console.error('Failed to copy markdown:', err);
                });
            },

            getAIUrl(provider) {
                const encodedContent = encodeURIComponent(this.markdown);
                const urls = {
                    'claude': `https://claude.ai/new?q=${encodedContent}`,
                    'openai': `https://chatgpt.com/?q=${encodedContent}`,
                    't3': `https://t3.chat/new?q=${encodedContent}`,
                    'perplexity': `https://www.perplexity.ai/search?q=${encodedContent}`
                };
                return urls[provider] || '#';
            },

            // tocScrollSpy properties
            headings: [],
            activeId: '',
            observer: null,

            init() {
                this.extractHeadings('wiki-content');
                this.setupScrollSpy();

                // Register refresh callback with store
                Alpine.store('toc').setRefreshCallback(() => {
                    this.refresh();
                });
            },

            refresh() {
                // Disconnect existing observer
                if (this.observer) {
                    this.observer.disconnect();
                }

                // Re-extract headings and setup scroll spy
                this.extractHeadings('wiki-content');
                this.setupScrollSpy();
            },

            extractHeadings(contentId) {
                const content = document.getElementById(contentId);
                if (!content) return;

                const headingElements = content.querySelectorAll('h2, h3');
                this.headings = Array.from(headingElements).map((heading, index) => {
                    // Ensure heading has an ID for linking
                    if (!heading.id) {
                        heading.id = `heading-${index}`;
                    }
                    // Get text before adding anchor
                    const text = heading.textContent.trim();
                    // Add anchor link if not already present
                    this.addAnchorLink(heading);
                    return {
                        id: heading.id,
                        text: text,
                        level: parseInt(heading.tagName.charAt(1))
                    };
                });

                // Set initial active heading
                if (this.headings.length > 0) {
                    this.activeId = this.headings[0].id;
                } else {
                    this.activeId = '';
                }
            },

            setupScrollSpy() {
                if (this.headings.length === 0) return;

                const options = {
                    root: null,
                    rootMargin: '-80px 0px -70% 0px',
                    threshold: 0
                };

                this.observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            this.activeId = entry.target.id;
                        }
                    });
                }, options);

                this.headings.forEach(heading => {
                    const element = document.getElementById(heading.id);
                    if (element) {
                        this.observer.observe(element);
                    }
                });
            },

            scrollToHeading(id) {
                const element = document.getElementById(id);
                if (element) {
                    element.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    // Update active immediately for better UX
                    this.activeId = id;
                    // Update URL hash without jumping
                    history.pushState(null, null, `#${id}`);
                }
            },

            addAnchorLink(heading) {
                // Skip if anchor already exists
                if (heading.querySelector('.heading-anchor')) return;

                const anchor = document.createElement('a');
                anchor.href = `#${heading.id}`;
                anchor.className = 'heading-anchor';
                anchor.setAttribute('aria-label', `Link to ${heading.textContent.trim()}`);
                anchor.textContent = '#';

                const self = this;
                anchor.addEventListener('click', (e) => {
                    e.preventDefault();
                    self.scrollToHeading(heading.id);
                    // Copy URL to clipboard
                    navigator.clipboard.writeText(window.location.origin + window.location.pathname + `#${heading.id}`);
                });

                heading.insertBefore(anchor, heading.firstChild);
            },

            destroy() {
                if (this.observer) {
                    this.observer.disconnect();
                }
            }
        }));
    });
</script>
{% endblock %}