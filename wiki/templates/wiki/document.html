{% extends "templates/wiki/layout.html" %}
{% from "templates/wiki/macros/buttons.html" import render_icon, page_actions_dropdown, page_action_item, dropdown_end %}

{% block title %}
    {{ doc.title }}
{% endblock %}

{% block head %}
<link rel="icon" href="{{ favicon or '/assets/wiki/favicon.png' }}">
{% endblock %}

{% block content %}
<div x-data="wikiPage" x-init="$store.navigation.init()" class="flex-1 min-w-0 flex">
    <!-- Main Content Area -->
    <main class="flex-1 min-w-0 px-4 py-6 lg:px-6 lg:py-8 xl:px-12 flex justify-center">
        <article class="w-full min-w-0 transition-[max-width,opacity] duration-300 xl:max-w-[80ch]"
             :class="{ 'opacity-50': $store.navigation.loading, 'xl:!max-w-[100ch]': $store.sidebar?.isCollapsed }">
        <!-- Page Header -->
        <header class="py-6 mb-6 border-b border-[var(--outline-gray-1)]">
            {% if hide_chrome %}
            {# Orphan document: Simple header with just copy button #}
            <div class="flex items-center justify-between gap-4">
                <h1 id="wiki-page-title" class="text-3xl font-semibold text-[var(--ink-gray-9)]">{{ doc.title }}</h1>
                <button @click="copyMarkdown()"
                        class="inline-flex items-center gap-1.5 px-3 py-1.5 text-sm font-medium text-[var(--ink-gray-7)] bg-[var(--surface-white)] border border-[var(--outline-gray-2)] rounded-lg hover:bg-[var(--surface-gray-1)] transition-colors duration-200 cursor-pointer">
                    <template x-if="!copied">
                        {{ render_icon("clipboard", "w-4 h-4") }}
                    </template>
                    <template x-if="copied">
                        {{ render_icon("check", "w-4 h-4 text-green-600") }}
                    </template>
                    <span x-text="copied ? 'Copied!' : 'Copy'"></span>
                </button>
            </div>
            {% else %}
            <!-- Mobile: Edit above title -->
            <div class="flex justify-start mb-4 sm:hidden">
                {{ page_actions_dropdown(edit_href=doc.get_edit_link(), edit_text="Edit") }}
                    {{ page_action_item(text="Copy page", description="Copy page as Markdown for LLMs", icon="clipboard", click="copyMarkdown(); open = false") }}
                    {{ page_action_item(text="Open in ChatGPT", description="Ask ChatGPT about this page", icon="openai", href_expr="getAIUrl('openai')", target="_blank") }}
                    {{ page_action_item(text="Open in Claude", description="Ask Claude about this page", icon="claude", href_expr="getAIUrl('claude')", target="_blank") }}
                {{ dropdown_end() }}
            </div>
            <div class="flex items-center justify-between gap-4">
                <h1 id="wiki-page-title" class="text-3xl font-semibold text-[var(--ink-gray-9)]">{{ doc.title }}</h1>

                <!-- Desktop: Edit beside title -->
                <div class="hidden sm:block">
                    {{ page_actions_dropdown(edit_href=doc.get_edit_link(), edit_text="Edit") }}
                        {{ page_action_item(text="Copy page", description="Copy page as Markdown for LLMs", icon="clipboard", click="copyMarkdown(); open = false") }}
                        {{ page_action_item(text="Open in ChatGPT", description="Ask ChatGPT about this page", icon="openai", href_expr="getAIUrl('openai')", target="_blank") }}
                        {{ page_action_item(text="Open in Claude", description="Ask Claude about this page", icon="claude", href_expr="getAIUrl('claude')", target="_blank") }}
                    {{ dropdown_end() }}
                </div>
            </div>
            {% endif %}
        </header>


        <!-- Page Content -->
        <div class="prose prose-sm max-w-none scroll-smooth" id="wiki-content">
            {{ rendered_content | safe }}
        </div>

        <!-- Previous/Next Navigation -->
        <nav id="wiki-nav-buttons" class="mt-12 pt-8 border-t border-[var(--outline-gray-1)]">
            {% if prev_doc or next_doc %}
            <div class="flex flex-col sm:flex-row sm:items-stretch gap-4 {{ 'sm:justify-between' if prev_doc and next_doc else ('sm:justify-start' if prev_doc else 'sm:justify-end') }}">
                {% if prev_doc %}
                <a href="/{{ prev_doc.route }}"
                   @click.prevent="$store.navigation.navigateTo('{{ prev_doc.route }}')"
                   @mouseenter="$store.navigation.prefetch('{{ prev_doc.route }}')"
                   class="group sm:flex-1 flex items-center gap-3 p-3 rounded-lg border border-[var(--outline-gray-1)] hover:border-[var(--outline-gray-2)] hover:bg-[var(--surface-gray-1)] transition-colors duration-200 no-underline sm:max-w-[50%] overflow-hidden">
                    {{ render_icon("chevron-left", "w-5 h-5 text-[var(--ink-gray-4)] group-hover:text-[var(--ink-gray-6)] transition-colors duration-200 shrink-0") }}
                    <div class="flex flex-col gap-1 min-w-0">
                        <span class="text-xs font-medium text-[var(--ink-gray-4)] uppercase tracking-wide">Previous Page</span>
                        <span class="text-sm font-medium text-[var(--ink-gray-7)] group-hover:text-[var(--ink-gray-9)] transition-colors duration-200 sm:truncate">{{ prev_doc.title }}</span>
                    </div>
                </a>
                {% endif %}

                {% if next_doc %}
                <a href="/{{ next_doc.route }}"
                   @click.prevent="$store.navigation.navigateTo('{{ next_doc.route }}')"
                   @mouseenter="$store.navigation.prefetch('{{ next_doc.route }}')"
                   class="group sm:flex-1 flex items-center gap-3 p-3 rounded-lg border border-[var(--outline-gray-1)] hover:border-[var(--outline-gray-2)] hover:bg-[var(--surface-gray-1)] transition-colors duration-200 no-underline sm:max-w-[50%] overflow-hidden {{ 'sm:ml-auto' if not prev_doc else '' }}">
                    <div class="flex flex-col gap-1 items-end min-w-0 ml-auto">
                        <span class="text-xs font-medium text-[var(--ink-gray-4)] uppercase tracking-wide">Next Page</span>
                        <span class="text-sm font-medium text-[var(--ink-gray-7)] group-hover:text-[var(--ink-gray-9)] transition-colors duration-200 sm:truncate text-right">{{ next_doc.title }}</span>
                    </div>
                    {{ render_icon("chevron-right", "w-5 h-5 text-[var(--ink-gray-4)] group-hover:text-[var(--ink-gray-6)] transition-colors duration-200 shrink-0") }}
                </a>
                {% endif %}
            </div>
            {% endif %}
        </nav>

        <!-- Last Updated & Feedback Widget -->
        <div class="mt-8 flex flex-col sm:flex-row sm:items-start sm:justify-between gap-4">
            <div id="wiki-last-updated" class="text-sm text-[var(--ink-gray-5)]" title="{{ last_updated_on }}" data-timestamp="{{ last_updated_on }}">
                Last updated {{ last_updated }}
            </div>
            {% if wiki_space and wiki_space.enable_feedback_collection %}
            {% include "templates/wiki/includes/feedback_widget.html" %}
            {% endif %}
        </div>
    </article>
    </main>

    {% if not hide_chrome %}
    {% include "templates/wiki/includes/toc.html" %}
    {% endif %}
</div>

<script>
    // Initialize page content store and wikiPage component for reactive updates during navigation
    document.addEventListener('alpine:init', () => {
        Alpine.store('pageContent', {
            markdown: {{ raw_markdown | tojson }}
        });

        // Combined component for wiki document page (wikiDocument + tocScrollSpy)
        Alpine.data('wikiPage', () => ({
            // wikiDocument properties
            copied: false,

            get markdown() {
                return this.$store.pageContent?.markdown || '';
            },

            copyMarkdown() {
                navigator.clipboard.writeText(this.markdown).then(() => {
                    this.copied = true;
                    setTimeout(() => {
                        this.copied = false;
                    }, 2000);
                }).catch(err => {
                    console.error('Failed to copy markdown:', err);
                });
            },

            getAIUrl(provider) {
                const pageUrl = window.location.href;
                const prompt = `I'm currently browsing this web page: ${pageUrl}\n\nPlease answer any questions I have based on the content of this page.`;
                const encodedPrompt = encodeURIComponent(prompt);
                const urls = {
                    'claude': `https://claude.ai/new?q=${encodedPrompt}`,
                    'openai': `https://chatgpt.com/?q=${encodedPrompt}`,
                    't3': `https://t3.chat/new?q=${encodedPrompt}`,
                    'perplexity': `https://www.perplexity.ai/search?q=${encodedPrompt}`
                };
                return urls[provider] || '#';
            },

            // tocScrollSpy properties - works with server-rendered TOC
            headingIds: [],
            activeId: '',
            observer: null,
            resizeHandler: null,
            scrollHandler: null,
            visibleHeadings: new Set(),

            init() {
                this.initScrollSpy();

                // Register refresh callback with store for SPA navigation
                Alpine.store('toc').setRefreshCallback(() => {
                    this.refresh();
                });
            },

            refresh() {
                // Disconnect existing observer and listeners
                if (this.observer) {
                    this.observer.disconnect();
                }
                if (this.resizeHandler) {
                    window.removeEventListener('resize', this.resizeHandler);
                }
                if (this.scrollHandler) {
                    window.removeEventListener('scroll', this.scrollHandler);
                }
                this.visibleHeadings.clear();

                // Re-initialize scroll spy
                this.initScrollSpy();
            },

            initScrollSpy() {
                // Get heading IDs from server-rendered TOC links
                const tocLinks = document.querySelectorAll('[data-toc-link]');
                this.headingIds = Array.from(tocLinks).map(link => link.dataset.tocLink);

                // Add anchor links to headings in content (even if TOC is empty)
                document
                    .querySelectorAll(
                        '#wiki-content h1[id], #wiki-content h2[id], #wiki-content h3[id], #wiki-content h4[id], #wiki-content h5[id], #wiki-content h6[id]',
                    )
                    .forEach(heading => {
                        this.addAnchorLink(heading);
                    });

                if (this.headingIds.length === 0) return;

                // Set initial active heading
                this.activeId = this.headingIds[0];
                this.updateTocLinkStyles();

                this.setupScrollSpy();
            },

            setupScrollSpy() {
                if (this.headingIds.length === 0) return;

                this.createObserver();

                // Handle scroll - needed to detect top-of-page state
                this.scrollHandler = () => {
                    this.updateActiveHeading();
                };
                window.addEventListener('scroll', this.scrollHandler, { passive: true });

                // Handle resize - need to recreate observer with new document height
                let resizeTimeout;
                this.resizeHandler = () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        if (this.observer) {
                            this.observer.disconnect();
                        }
                        this.visibleHeadings.clear();
                        this.createObserver();
                    }, 100);
                };
                window.addEventListener('resize', this.resizeHandler, { passive: true });
            },

            createObserver() {
                // Use document height as top margin so headings STAY intersecting after scrolling past
                // Use -66% bottom margin so headings only START intersecting in top 33% of viewport
                const docHeight = document.documentElement.scrollHeight;
                const options = {
                    root: null,
                    rootMargin: `${docHeight}px 0px -66% 0px`,
                    threshold: 0
                };

                this.observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            this.visibleHeadings.add(entry.target.id);
                        } else {
                            this.visibleHeadings.delete(entry.target.id);
                        }
                    });

                    this.updateActiveHeading();
                }, options);

                this.headingIds.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        this.observer.observe(element);
                    }
                });
            },

            updateActiveHeading() {
                if (this.headingIds.length === 0) return;

                let newActiveId = this.activeId;

                // When at the top of the page, always highlight the first heading
                if (window.scrollY < 100) {
                    newActiveId = this.headingIds[0];
                } else if (this.visibleHeadings.size === 0) {
                    // No headings visible - keep current or set to first
                    if (!this.activeId) {
                        newActiveId = this.headingIds[0];
                    }
                } else {
                    // Find the last visible heading in DOM order (most recently scrolled past)
                    const visibleInOrder = this.headingIds.filter(id => this.visibleHeadings.has(id));
                    if (visibleInOrder.length > 0) {
                        newActiveId = visibleInOrder[visibleInOrder.length - 1];
                    }
                }

                // Only update DOM if active heading changed
                if (newActiveId !== this.activeId) {
                    this.activeId = newActiveId;
                    this.updateTocLinkStyles();
                }
            },

            updateTocLinkStyles() {
                // Update the active class on server-rendered TOC links
                document.querySelectorAll('[data-toc-link]').forEach(link => {
                    if (link.dataset.tocLink === this.activeId) {
                        link.classList.add('active');
                    } else {
                        link.classList.remove('active');
                    }
                });
            },

            addAnchorLink(heading) {
                // Skip if anchor already exists
                if (heading.querySelector('.heading-anchor')) return;

                const anchor = document.createElement('a');
                anchor.href = `#${heading.id}`;
                anchor.className = 'heading-anchor';
                anchor.setAttribute('aria-label', `Link to ${heading.textContent.trim()}`);
                anchor.textContent = '#';
                heading.insertBefore(anchor, heading.firstChild);
            },

            destroy() {
                if (this.observer) {
                    this.observer.disconnect();
                }
                if (this.resizeHandler) {
                    window.removeEventListener('resize', this.resizeHandler);
                }
                if (this.scrollHandler) {
                    window.removeEventListener('scroll', this.scrollHandler);
                }
                this.visibleHeadings.clear();
            }
        }));
    });
</script>
{% endblock %}
